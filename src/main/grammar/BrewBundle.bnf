// Copyright 2000-2020 JetBrains s.r.o. and other contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
{
  parserClass="co.anbora.labs.brewbundle.lang.core.parser.BrewParser"
  psiClassPrefix="Brew"
  psiImplClassSuffix="Impl"

  implements="co.anbora.labs.brewbundle.lang.core.psi.BrewElement"
  extends="co.anbora.labs.brewbundle.lang.core.psi.BrewElementImpl"

  psiPackage="co.anbora.labs.brewbundle.lang.core.psi"
  psiImplPackage="co.anbora.labs.brewbundle.lang.core.psi.impl"
  parserUtilClass="co.anbora.labs.brewbundle.lang.core.util.BrewParserUtil"

  elementTypeHolderClass="co.anbora.labs.brewbundle.lang.core.psi.BrewTypes"

  elementTypeClass="co.anbora.labs.brewbundle.lang.core.BrewElementType"
  tokenTypeClass="co.anbora.labs.brewbundle.lang.core.BrewTokenType"

  tokens = [
    WHITESPACE       ='regexp:[ \n\t\r\f]'

    BOOL_LITERAL     ='regexp:(true)|(false)'
    NUMBER_LITERAL   ='regexp:\d+(\.\d*)?'
    STRING_LITERAL   ="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

    IDENTIFIER       ='regexp:[\-_a-zA-Z0-9]+'
    ENVIRONMENT      ='regexp::[\-_a-zA-Z0-9]+'

    L_BRACE          =  '{'
    R_BRACE          =  '}'
    L_BRACK          =  '['
    R_BRACK          =  ']'
    COLON            =  ':'
    COMMA            =  ','
    DOT              =  '.'

    SYSTEM           = 'system_kw'

  ]
}

// Naming convention:
//
//   * tokens are lowercase: for, if, identifier
//   * rules are PascalCase: StructItem
//   * recovery related rules are PascalCase_with_snake_suffix: Item_recover

File ::= item_*

private item_ ::= (TapProperty | CaskArgsProperty | BrewProperty | CaskProperty | MasProperty | WhaleBrewProperty)

TapProperty ::= tap <<comma_sep_items (StringLitOrProperty &(','|StringLitOrProperty))>> {pin=1 recoverWhile=recover_item}

CaskArgsProperty ::= CASK_ARGS <<comma_sep_items (Property &(','|Property))>> {pin=1 recoverWhile=recover_item}

BrewProperty ::= brew <<comma_sep_items (StringLitOrProperty &(','|StringLitOrProperty))>> {pin=1 recoverWhile=recover_item}

CaskProperty ::= cask <<comma_sep_items (StringLitOrProperty &(','|StringLitOrProperty))>> {pin=1 recoverWhile=recover_item}

MasProperty ::= mas <<comma_sep_items (StringLitOrProperty &(','|StringLitOrProperty))>> {pin=1 recoverWhile=recover_item}

WhaleBrewProperty ::= whalebrew <<comma_sep_items (StringLitOrProperty &(','|StringLitOrProperty))>> {pin=1 recoverWhile=recover_item}

private recover_item ::= !(tap | CASK_ARGS | brew | cask | mas | whalebrew)

private StringLitOrProperty ::= StringLit | Property

Property ::= [] PropertyName ':' value {pin=1 recoverWhile=recover}

PropertyName ::= IDENTIFIER
private recover ::= !(',' | ']' | '}' | '[' | '{')

json ::= array | object  { hooks=[wsBinders="null, null"] }
value ::= BOOL_LITERAL | StringLit | ENVIRONMENT | NUMBER_LITERAL | UnlessLit | json {name="value"}

array ::= '[' [!']' item (!']' ',' item) *] ']' {pin(".*")=1 extends=json}
private item ::= StringLit | json {recoverWhile=recover}
object ::= '{' [!'}' Property (!'}' ',' Property) *] '}' {pin(".*")=1 extends=json}

StringLit ::= STRING_LITERAL

UnlessLit ::= unless IDENTIFIER StringLit

private meta comma_sep_items ::= <<param>> ( ',' <<param>> )* ','?
